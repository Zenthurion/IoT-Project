"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var events = require("eventemitter2");
var lib_1 = require("./lib");
var TimerJobs = (function () {
    function TimerJobs(options, callback) {
        this.errors = [];
        this.executions = 0;
        this.start_wait = 0;
        this.hasStarted = false;
        if (lib_1.isFunction(options)) {
            callback = options;
            options = {};
        }
        if (lib_1.not(lib_1.isFunction(callback))) {
            throw new Error('TimerJobs Error: a callback must be provided');
        }
        this.blocking =
            options.blocking === undefined ? true : Boolean(options.blocking);
        this.interval = lib_1.isInteger(options.interval) ? options.interval : 3000;
        this.autoStart = Boolean(options.autoStart);
        this.immediate = Boolean(options.immediate);
        this.ignoreErrors = Boolean(options.ignoreErrors);
        this.infinite =
            options.infinite === undefined ? true : Boolean(options.infinite);
        this.countdown = options.countdown;
        this.reference = options.reference || 'timer';
        this.namespace = lib_1.isString(options.namespace) ? options.namespace : '';
        this.stopOn = options.stopOn || null;
        this.stopCallback = lib_1.isFunction(options.stopCallback)
            ? options.stopCallback
            : null;
        this.startOn = options.startOn || null;
        this.startCallback = lib_1.isFunction(options.startCallback)
            ? options.startCallback
            : null;
        this.restartOn =
            options.restartOn && options.restartOn.trim().length
                ? options.restartOn
                : null;
        this.restartCallback = lib_1.isFunction(options.restartCallback)
            ? options.restartCallback
            : null;
        this.delimiter = options.delimiter || '::';
        this.emitter =
            options.emitter ||
                TimerJobs.emitter ||
                new events.EventEmitter2({ wildcard: true, delimiter: this.delimiter });
        this.timer = null;
        this.busy = false;
        this.callback = callback;
        this.emitLevel = options.emitLevel;
        if (!this.namespace.length) {
            if (this.emitLevel === 2) {
                this.emitLevel = 1;
            }
            else if (this.emitLevel === 3) {
                this.emitLevel = 4;
            }
        }
        this.LEVEL = {
            1: '',
            2: this.delimiter + this.namespace,
            3: this.delimiter + this.namespace + this.delimiter + this.reference,
            4: this.delimiter + this.reference,
        };
        this.setupListeners();
        if (this.autoStart) {
            this.start();
        }
        TimerJobs.timers.push(this);
    }
    TimerJobs.prototype.start = function () {
        if (!this.timer) {
            this.start_wait = Date.now();
            this.hasStarted = true;
            if (this.countdown < 1) {
                this.countdown = this.__countdown;
            }
            this.timer = setInterval(this.go.bind(this), this.interval);
            if (this.emitLevel) {
                this.emitter.emit("jobStart" + this.LEVEL[this.emitLevel], this);
            }
            if (this.immediate) {
                this.go();
            }
        }
    };
    TimerJobs.prototype.stopped = function () {
        return this.timer === null;
    };
    TimerJobs.prototype.started = function () {
        return Boolean(this.timer);
    };
    TimerJobs.prototype.stop = function () {
        if (this.timer) {
            clearInterval(this.timer);
            if (this.emitLevel) {
                this.emitter.emit("jobStop" + this.LEVEL[this.emitLevel], this);
            }
            this.timer = null;
            this.start_wait = 0;
        }
    };
    TimerJobs.prototype.restart = function (interval) {
        if (interval === void 0) { interval = this.interval; }
        if (lib_1.not(lib_1.isInteger(interval)) || interval < 1) {
            interval = this.interval;
        }
        this.interval = interval;
        if (this.hasStarted) {
            this.stop();
            this.start();
        }
    };
    TimerJobs.prototype.waitTime = function () {
        if (!this.start_wait) {
            return this.start_wait;
        }
        return this.start_wait + this.interval - Date.now();
    };
    Object.defineProperty(TimerJobs.prototype, "countdown", {
        get: function () {
            return this._countdown;
        },
        set: function (value) {
            this.__countdown = this._countdown =
                value && value > 1 ? Math.floor(value) : 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TimerJobs.prototype, "emitLevel", {
        get: function () {
            return this._emitLevel;
        },
        set: function (value) {
            this._emitLevel = lib_1.isInteger(value) && lib_1.inRange(value, 0, 5) ? value : 1;
        },
        enumerable: true,
        configurable: true
    });
    TimerJobs.findTimers = function (property, match) {
        var timers = [];
        this.timers.forEach(function (timer) {
            if (timer[property] === match) {
                timers.push(timer);
            }
        });
        return timers;
    };
    TimerJobs.removeTimers = function (timers, stop) {
        if (stop === void 0) { stop = true; }
        if (!Array.isArray(timers)) {
            timers = [timers];
        }
        timers.forEach(function (timer) {
            var index = TimerJobs.timers.indexOf(timer);
            if (index >= 0) {
                TimerJobs.timers.splice(index, 1);
                stop && timer.stop();
            }
        });
    };
    TimerJobs.prototype.go = function () {
        if (!this.busy || !this.blocking) {
            this.busy = true;
            if (this.emitLevel) {
                this.emitter.emit("jobBegin" + this.LEVEL[this.emitLevel], this);
            }
            ++this.executions;
            this.start_wait = Date.now();
            this.callback(this.done.bind(this));
        }
    };
    TimerJobs.prototype.done = function (err) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.emitLevel) {
            var emission = "jobEnd" + this.LEVEL[this.emitLevel];
            this.emitter.emit.apply(this.emitter, [emission, this].concat(args));
        }
        if (err) {
            var level = void 0;
            this.errors.push(err);
            if (this.emitLevel) {
                level = this.LEVEL[this.emitLevel];
            }
            else {
                level = this.LEVEL[1];
            }
            this.emitter.emit("jobError" + level, err, this, this.errors);
            if (!this.ignoreErrors) {
                this.stop();
            }
        }
        if (!this.infinite) {
            if (--this._countdown < 1) {
                if (this.emitLevel) {
                    this.emitter.emit("jobComplete" + this.LEVEL[this.emitLevel], this);
                }
                this.stop();
            }
        }
        this.busy = false;
    };
    TimerJobs.prototype.setupListeners = function () {
        var _this = this;
        if (this.stopOn) {
            this.emitter.on(this.stopOn, function () {
                var rest = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    rest[_i] = arguments[_i];
                }
                var _a;
                _this.stop();
                if (_this.stopCallback) {
                    (_a = _this.stopCallback).call.apply(_a, [null].concat(rest));
                }
            });
        }
        if (this.startOn) {
            this.emitter.on(this.startOn, function () {
                var rest = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    rest[_i] = arguments[_i];
                }
                var _a;
                if (_this.stopped()) {
                    _this.start();
                    if (_this.startCallback) {
                        (_a = _this.startCallback).call.apply(_a, [null].concat(rest));
                    }
                }
            });
        }
        if (this.restartOn) {
            this.emitter.on(this.restartOn, function () {
                var rest = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    rest[_i] = arguments[_i];
                }
                var _a;
                if (_this.hasStarted) {
                    _this.restart();
                    if (_this.restartCallback)
                        (_a = _this.restartCallback).call.apply(_a, [null].concat(rest));
                }
            });
        }
    };
    TimerJobs.timers = [];
    return TimerJobs;
}());
exports.TimerJobs = TimerJobs;
